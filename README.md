

## **0. 프로젝트 진행 계기**
- **문제 인식:**
    - LeetCode에서 재귀적으로 DP문제를 풀어내는 과정에서 재귀 기반 DP 알고리즘을 최적화하는 데 있어 **변수 전달 방식**(Call by Value vs Call by Reference) 이 성능에 큰 영향을 미칠 수 있다는 점을 깨달았다!
    - 따라서 **메모리 사용량**과 **함수 호출의 오버헤드**가 성능에 미치는 영향을 실제로 실험하여 확인하고자 한다.
   
- **기대 효과:**
    -  코드 최적화 후 **성능 차이**를 **프론트엔드**에서 실시간으로 확인할 수 있도록 하여 내가 꺠달은 바를
  다른 개발자들이랑 협업할 때  **성능 최적화**에 대한 중요성을 쉽게 이해할 수 있도록 도울 수 있지 않을까 싶다!

---
## **1. 프로젝트 소개**
- **프로젝트명:** DP Optimization with Recursive Parameter Passing
- **목적:**
    - 재귀 기반 DP 알고리즘의 성능 최적화를 목표로 변수 전달 방식(Call by Value vs Call by Reference)에 따른 오버헤드 차이 분석.
    - 성능 최적화 기법 적용 및 결과 검증.
- **구성:**
    - 3일 동안 단계별로 진행되는 최적화 과정 정리.
    - 프론트엔드를 통해 사용자 입력과 최적화 결과 시각화 제공.

---

## **2. 폴더 구조**
```
📂 dp-optimization-project
├── 📂 day1 (문제 정의 및 초기 코드 작성)
├── 📂 day2 (최적화 적용 및 성능 테스트)
├── 📂 day3 (최종 분석 및 보고서 작성)
└── 📄 README.md (프로젝트 개요 및 설명)
```

---

## **3. 진행 일정 및 구성**
### **Day 1: 문제 정의 및 초기 코드 작성**
- **목표:** 성능 병목 지점 확인.
- **내용:**
    1. 문제 정의 및 예제 코드 설명.
    2. 초기 코드 작성 및 비효율적 접근 식별.
    3. 프로파일링 도구 설정 및 기본 성능 측정.

### **Day 2: 최적화 적용 및 성능 테스트**
- **목표:** 최적화 적용 후 성능 변화 확인.
- **내용:**
    1. 최적화 기법 적용(메모이제이션, 매개변수 전달 방식 변경 등).
    2. 최적화 코드 작성 및 테스트 결과 기록.
    3. 최적화 전후 성능 비교 그래프 생성.

### **Day 3: 최종 분석 및 보고서 작성**
- **목표:** 결과 분석 및 시각화.
- **내용:**
    1. 최종 결과 분석 및 성능 그래프 작성.
    2. 비교 분석 결과 문서화.
    3. 코드 및 문서 정리.
-------

## **4. 주요 기능**
1. **코드 최적화:**
    - 변수 전달 방식(Call by Value vs Call by Reference) 성능 차이 분석.
    - DP 성능 개선 기법 적용 및 검증.

2. **프론트엔드 인터페이스:**
    - 사용자 입력 폼을 통한 데이터 입력.
    - 성능 결과 및 최적화 전후 비교 그래프 시각화.

3. **성능 측정:**
    - 처리 시간, 메모리 사용량 및 그래프 출력.

---

## **5. 사용 방법**
1. **프로젝트 클론 및 빌드:**
   ```bash
   git clone https://github.com/username/dp-optimization-project.git
   cd dp-optimization-project
   ```
2. **백엔드 실행:**
   ```bash
   cd backend
   mvn spring-boot:run
   ```
3. **프론트엔드 실행:**
   ```bash
   cd frontend
   npm install
   npm start
   ```
